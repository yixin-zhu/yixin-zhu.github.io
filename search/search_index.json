{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":""},{"location":"about/","title":"I am Yixin","text":""},{"location":"about/#friend-link","title":"Friend Link","text":""},{"location":"about/#yilins-blog","title":"Yilin's blog","text":"<p>https://elin16.github.io/</p>"},{"location":"learn/C%2B%2B/1environment/","title":"C++ Basic Knowledge","text":""},{"location":"learn/C%2B%2B/1environment/#vm-ssh","title":"VM, SSH","text":"<p>We use VMware Workstation to run our Ubuntu.</p> <p>And ssh to it to practice working without Graphical User Interface.</p>"},{"location":"learn/C%2B%2B/1environment/#gcc","title":"GCC","text":""},{"location":"learn/C%2B%2B/1environment/#install-and-check","title":"install and check","text":"<pre><code>sudo apt install gcc g++\ng++ --version\n</code></pre>"},{"location":"learn/C%2B%2B/1environment/#basic-use","title":"basic use","text":"<p>You can use ctrl+l to clear the terminal. <pre><code>gcc test.c -o app\n./app\n\ngcc test.c -E -o test.i\ngcc test.i -S -o test.s\ngcc test.s -s -o test.o\ngcc test.c -o2\ngcc test.c -D DEBUG\n</code></pre> the last one should be used with <pre><code>#ifdef DEBUG\n// something\n#endif\n</code></pre></p>"},{"location":"learn/C%2B%2B/1environment/#gcc-and-g","title":"gcc and g++","text":"<ul> <li>gcc and g++ can both be used for c and c++ program. However, g++ can't link with c++'s library automatically. must use 'gcc -lstdc++'</li> </ul>"},{"location":"learn/C%2B%2B/1environment/#library","title":"Library","text":"<p>Library is also a kind of program, but can't be used alone.</p> <p>Static libraries are copied at link time, dynamic libraries are loaded at runtime.</p>"},{"location":"learn/C%2B%2B/1environment/#static-libraries","title":"Static libraries","text":"<p>libxxx.a(Linux), libxxx.lib(Windows) <pre><code>gcc -c xxx.c\nar rcs libxxx.a xxx.o xxx.o\n\n# use example\ngcc main.c -o app -I ./include/ -l xxx -L ./library\n# -I means the directory to find head files to include\n# -L means the directory of the library\n</code></pre></p>"},{"location":"learn/C%2B%2B/1environment/#dynamic-libraries","title":"dynamic libraries","text":"<p>libxxx.so(Linux), libxxx.dll(Windows) <pre><code># build dynamic library\n# -fpic means 'Generate position-independent code (PIC) suitable for use in a shared library'\ngcc -c -fpic a.c b.c\ngcc -shared a.o b.o -o libcalc.so\n\n# use example\ngcc main.c -o main -I  include/ -l lib/ -L calc\n# ld-linux.so tries to find dynamic dependency\nvim ~/.bashrc\n# add\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/a/b\n# quit and\nsource ~/.bashrc\n./main\n</code></pre></p>"},{"location":"learn/C%2B%2B/1environment/#difference","title":"Difference","text":"<p>Source Code -&gt; Preprocessing -&gt; Compilation -&gt; Assembly -&gt; Linking -&gt; executable files</p> <p>static pros: faster, convenient</p> <p>static cons: waste of memory, hard to update</p> <p>dynamic pros: easy to share between process , easy to update, more control</p> <p>dynamic cons: slower, need to offer dynamic library</p>"},{"location":"learn/C%2B%2B/1environment/#makefile","title":"Makefile","text":"<p>target: dependencies</p> <p>[Tab] command</p> <p><pre><code>objects = a.o cal.o\n\napp : $(objects)\ng++ -o app $(objects)\na.o : cal.h\n\ncal.o : cal.h\n\n.PHONY : clean\nclean : rm app $(objects)\n</code></pre> Makefile will firstly checks the dependency and then update.</p>"},{"location":"learn/algorithm/AnalysisOfAlgorithms/","title":"Analysis Of Algorithms","text":""},{"location":"learn/algorithm/AnalysisOfAlgorithms/#scientific-method","title":"Scientific method.","text":"<ul> <li> <p>Observe some feature of the natural world.</p> </li> <li> <p>Hypothesize a model that is consistent with the observations. </p> </li> <li> <p>Predict events using the hypothesis.</p> </li> <li> <p>Verify the predictions by making further observations.</p> </li> <li> <p>Validate by repeating until the hypothesis and observations agree.</p> </li> </ul>"},{"location":"learn/algorithm/AnalysisOfAlgorithms/#observations","title":"Observations","text":""},{"location":"learn/algorithm/AnalysisOfAlgorithms/#measuring-the-running-time","title":"Measuring the running time","text":"<pre><code>public static void main(String[] args)\n{\nint[] a = In.readInts(args[0]); Stopwatch stopwatch = new Stopwatch(); StdOut.println(ThreeSum.count(a)); double time = stopwatch.elapsedTime();\n}\n</code></pre>"},{"location":"learn/algorithm/AnalysisOfAlgorithms/#doubling-hypothesis","title":"Doubling hypothesis","text":"<p>Quick way to estimate b in a power-law relationship.</p> <p>Run program, doubling the size of the input.</p>"},{"location":"learn/algorithm/AnalysisOfAlgorithms/#mathematical-models","title":"mathematical models","text":"<p>total running time:  sum of cost \u00d7 frequency for all operations.</p> <p>Cost model</p> <ul> <li> <p>Use some basic operation as a proxy for running time.</p> </li> <li> <p>Estimate running time (or memory) as a function of input size N.</p> </li> <li> <p>Ignore lower order terms.</p> </li> </ul>"},{"location":"learn/algorithm/AnalysisOfAlgorithms/#order-of-growth-classifications","title":"order-of-growth classifications","text":"<p>the small set of functions 1,  log N,  N,  N log N,  N^2,  N^3, and 2^N suffices to describe order-of-growth of typical algorithms.</p>"},{"location":"learn/algorithm/AnalysisOfAlgorithms/#theory-of-algorithms","title":"theory of algorithms","text":"<p>Best case:Lower bound on cost.Determined by \u201ceasiest\u201d input.Provides a goal for all inputs.</p> <p>Worst case:Upper bound on cost. Determined by \u201cmost difficult\u201d input.Provides a guarantee for all inputs.</p> <p>Average case:Expected cost for random input. Need a model for \u201crandom\u201d input. Provides a way to predict performance.</p> <p>Optimal algorithm:Performance guarantee (to within a constant factor) for any input.No algorithm can provide a better performance guarantee.</p>"},{"location":"learn/algorithm/AnalysisOfAlgorithms/#memory","title":"memory","text":""},{"location":"learn/algorithm/AnalysisOfAlgorithms/#k","title":"k","text":"<p>char 2</p> <p>int float 4</p> <p>long double 8</p>"},{"location":"learn/algorithm/AnalysisOfAlgorithms/#array","title":"array","text":"<p>kN + 24</p>"},{"location":"learn/algorithm/AnalysisOfAlgorithms/#typical-memory-usage-for-objects-in-java","title":"Typical memory usage for objects in Java","text":"<p>Object overhead.  16 bytes. Reference.  8 bytes. Padding.  Each object uses a multiple of 8 bytes.</p>"},{"location":"learn/algorithm/BagQueueStack/","title":"Bag, Queue and Stack","text":"<p>Stack</p> <p>Examine the item most recently added. </p> <p>Queue</p> <p>Examine the item least recently added.</p> <pre><code>public class FixedCapacityStackOfStrings\n{\nprivate String[] s; private int N = 0;\npublic FixedCapacityStackOfStrings(int capacity) {  s = new String[capacity];  }\npublic boolean isEmpty() {  return N == 0;  }\npublic void push(String item) {  s[N++] = item;  }\npublic String pop()\n{  return s[--N];  }\n}\n</code></pre>"},{"location":"learn/algorithm/unionFind/","title":"Union Find","text":""},{"location":"learn/algorithm/unionFind/#dynamic-connectivity","title":"Dynamic connectivity","text":"<pre><code>public class UF{\nUF(int N) //initialize union-find data structure with N objects (0 to N \u2013 1)\n// Find query.  Check if two objects are in the same component.\nboolean connected(int p, int q) // are p and q in the same component?\n// Union command.  Replace components containing two objects with their union.\nvoid union(int p, int q) add connection between p and q\n}\n</code></pre>"},{"location":"learn/algorithm/unionFind/#quick-find","title":"Quick Find","text":"<p>Data structure. - Integer array id[] of length N. - Interpretation:  p and q are connected iff they have the same id.</p> <pre><code>// O(1)\npublic boolean connected(int p, int q) {  return id[p] == id[q];  }\n// O(N)\npublic void union(int p, int q){\n{\nint pid = id[p];\nint qid = id[q];\nfor (int i = 0; i &lt; id.length; i++) if (id[i] == pid) id[i] = qid;\n}\n}\n</code></pre>"},{"location":"learn/algorithm/unionFind/#quick-union","title":"Quick Union","text":"<p>Data structure. - Integer array id[] of length N. - Interpretation:  id[i] is parent of i. \u027eRoot of i is id[id[id[...id[i]...]]].</p> <pre><code>private int root(int i)\n{\nwhile (i != id[i]) i = id[i];  // go to root\nreturn i;\n}\n// O(N)\npublic boolean connected(int p, int q) {  return root(p) == root(q);  }\n// O(N)\npublic void union(int p, int q){\n{\nint i = root(p);\nint j = root(q);\nid[i] = j;\n}\n}\n</code></pre>"},{"location":"learn/algorithm/unionFind/#union-find_1","title":"Union Find","text":""},{"location":"learn/algorithm/unionFind/#improvement1-weighting","title":"Improvement1: Weighting","text":"<p>Weighted quick-union. - Modify quick-union to avoid tall trees. - Keep track of size of each tree (number of objects).  - Balance by linking root of smaller tree to root of larger tree.</p> <p>Data structure.  - Same as quick-union, but maintain extra array sz[i] to count number of objects in the tree rooted at i.</p> <pre><code>private int root(int i)\n{\nwhile (i != id[i]) i = id[i];  // go to root\nreturn i;\n}\n// O(lgN) This is because Depth of any node x is at most lg N.\npublic boolean connected(int p, int q) {  return root(p) == root(q);  }\n// O(lgN)\npublic void union(int p, int q){\n{\nint i = root(p);\nint j = root(q);\nif (i == j) return;\nif  (sz[i] &lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else                { id[j] = i; sz[i] += sz[j]; }\n}\n}\n</code></pre>"},{"location":"learn/algorithm/unionFind/#improvement2-path-compression","title":"Improvement2: path compression","text":"<p>Quick union with path compression. - Just after computing the root of p, set the id of each examined node to point to that root.</p> <p>Data structure.  - Same as quick-union, but maintain extra array sz[i] to count number of objects in the tree rooted at i.</p> <pre><code>private int root(int i)\n{\nwhile (i != id[i]){\nid[i] = id[id[i]]; // only one extra code! In practice, just set the node to its grandparent, no need to root.\ni = id[i];\n}   return i;\n}\n// O(lgN) This is because Depth of any node x is at most lg N.\npublic boolean connected(int p, int q) {  return root(p) == root(q);  }\n// O(lgN)\npublic void union(int p, int q){\n{\nint i = root(p);\nint j = root(q);\nif (i == j) return;\nif  (sz[i] &lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else                { id[j] = i; sz[i] += sz[j]; }\n}\n}\n</code></pre> <p>Proposition.  </p> <p>[Hopcroft-Ulman, Tarjan] Starting from an empty data structure, any sequence of M union-find operationss on N objects makes \u2264  c ( N + M lg N ) array accesses.  (log is iterate log)</p> <ul> <li>Analysis can be improved to N + M \u03b1(M, N).</li> <li>Simple algorithm with fascinating mathematics.</li> <li>In practice, WQUPC is near linear!</li> </ul>"},{"location":"learn/cryptography/General/","title":"\u73af\u6e38\u5bc6\u7801\u4e16\u754c","text":""},{"location":"learn/cryptography/General/#_2","title":"\u5bc6\u7801\u5b66\u5bb6\u7684\u5de5\u5177\u7bb1","text":"<p>\u5bf9\u79f0\u5bc6\u7801: \u5728\u52a0\u5bc6\u548c\u89e3\u5bc6\u65f6\u4f7f\u7528\u540c\u4e00\u5bc6\u94a5\u3002</p> <p>\u516c\u94a5\u5bc6\u7801: \u53c8\u79f0\u975e\u5bf9\u79f0\u5bc6\u7801\u3002\u5728\u52a0\u5bc6\u548c\u89e3\u5bc6\u65f6\u4f7f\u7528\u4e0d\u540c\u7684\u5bc6\u94a5\u3002</p> <p>\u5355\u5411\u6563\u5217\u51fd\u6570: \u7528\u6765\u4fdd\u8bc1\u8f6f\u4ef6\u7684\u5b8c\u6574\u6027\u3002\u4e0b\u8f7d\u8005\u53ef\u4ee5\u901a\u8fc7\u5bf9\u6bd4\u81ea\u5df1\u4e0b\u8f7d\u7684\u8f6f\u4ef6\u7684\u6563\u5217\u503c\uff0c\u548c\u53d1\u5e03\u8005\u516c\u5e03\u7684\u6563\u5217\u503c\u5bf9\u6bd4\uff0c\u4fdd\u8bc1\u6b63\u786e\u3002</p> <p>\u6d88\u606f\u9a8c\u8bc1\u7801: \u4e0d\u4ec5\u53ef\u4ee5\u786e\u8ba4\u6d88\u606f\u662f\u5426\u88ab\u7be1\u6539\uff0c\u800c\u4e14\u786e\u8ba4\u6d88\u606f\u662f\u5426\u6765\u81ea\u6240\u671f\u5f85\u7684\u901a\u4fe1\u5bf9\u8c61\u3002</p> <p>\u6570\u5b57\u7b7e\u540d: \u7c7b\u4f3c\u4e8e\u73b0\u5b9e\u4e2d\u7684\u7b7e\u7ae0\uff0c\u53ef\u4ee5\u7531\u5bf9\u65b9\u9a8c\u8bc1\u3002</p> <p>\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668: \u5982\u679c\u751f\u6210\u7b97\u6cd5\u4e0d\u597d\uff0c\u5bb9\u6613\u88ab\u63a8\u6d4b\u51fa\u5bc6\u94a5\u3002</p> <p>\u9690\u5199\u672f: \u5c06\u6d88\u606f\u672c\u8eab\u9690\u85cf\u8d77\u6765\uff0c\u5982\u628a\u6587\u7ae0\u5b58\u5230\u56fe\u7247\u91cc\u3002</p>"},{"location":"learn/cryptography/General/#_3","title":"\u5bc6\u7801\u4e16\u754c\u7684\u5e38\u8bc6","text":"<ul> <li> <p>\u4e0d\u8981\u4f7f\u7528\u4fdd\u5bc6\u7684\u5bc6\u7801\u7b97\u6cd5</p> </li> <li> <p>\u4f7f\u7528\u4f4e\u5f3a\u5ea6\u7684\u5bc6\u7801\u6bd4\u4e0d\u52a0\u5bc6\u66f4\u5371\u9669</p> </li> <li> <p>\u4efb\u4f55\u5bc6\u7801\u603b\u6709\u4e00\u5929\u4f1a\u7834\u89e3</p> </li> <li> <p>\u5bc6\u7801\u53ea\u662f\u4fe1\u606f\u5b89\u5168\u7684\u4e00\u90e8\u5206</p> </li> </ul>"},{"location":"learn/cryptography/General/#_4","title":"\u5386\u53f2\u4e0a\u7684\u5bc6\u7801","text":""},{"location":"learn/cryptography/General/#_5","title":"\u51ef\u6492\u5bc6\u7801","text":"<p>\u4f7f\u7528\u7b80\u5355\u7684\u79fb\u4f4d\uff0c\u53ef\u4ee5\u4f7f\u7528\u66b4\u529b\u7834\u89e3\u65b9\u5f0f\u3002</p>"},{"location":"learn/cryptography/General/#_6","title":"\u7b80\u5355\u66ff\u6362\u5bc6\u7801","text":"<p>\u5b57\u6bcd\u4e00\u5bf9\u4e00\u8fdb\u884c\u66ff\u6362\uff0c\u53ef\u4ee5\u4f7f\u7528\u9891\u7387\u5206\u6790\u7684\u65b9\u6cd5\u6765\u7834\u8bd1\u3002</p>"},{"location":"learn/cryptography/General/#enigma","title":"Enigma\u5bc6\u7801","text":"<p>\u4e8c\u6218\u65f6\u5fb7\u56fd\u4f7f\u7528\u7684\u4e00\u79cd\u5bc6\u7801\uff0c\u662f\u4e00\u79cd\u66ff\u6362\u5bc6\u7801\u3002\u4f46\u540c\u76df\u56fd\u7528\u7a77\u4e3e\u7b49\u65b9\u5f0f\u7834\u8bd1\u3002</p>"},{"location":"learn/cryptography/General/#_7","title":"\u5bf9\u79f0\u5bc6\u7801\uff08\u5171\u4eab\u5bc6\u94a5\u5bc6\u7801\uff09","text":""},{"location":"learn/cryptography/General/#_8","title":"\u5f02\u6216\u5bc6\u7801","text":"<p>\u56e0\u4e3a\u4ee5\u4e0b\u6027\u8d28 $$ C = A ^ B A = C ^ B B = C ^ A $$ \u4f7f\u5f97\u901a\u8fc7\u5f02\u6216\u8fd0\u7b97\u53ef\u4ee5\u5b8c\u6210\u52a0\u5bc6\u548c\u8fd8\u539f\u3002</p>"},{"location":"learn/cryptography/General/#_9","title":"\u4e00\u6b21\u6027\u5bc6\u7801\u672c","text":"<p>\u4f7f\u7528\u5b8c\u5168\u968f\u673a\u7684\u5bc6\u94a5\u548c\u660e\u6587\u5f02\u6216\uff0c\u5c31\u5f97\u5230\u4e86\u5bc6\u6587\u3002\u5bc6\u6587\u518d\u6b21\u4e0e\u5bc6\u94a5\u5f02\u6216\uff0c\u5c31\u53ef\u4ee5\u5f97\u5230\u660e\u6587\u3002\u7a77\u4e3e\u6240\u6709\u5bc6\u94a5\uff0c\u90a3\u4e48\u6240\u6709\u76f8\u540c\u957f\u5ea6\u7684\u6587\u672c\u90fd\u4f1a\u51fa\u73b0\uff0c\u65e0\u6cd5\u77e5\u9053\u54ea\u4e2a\u624d\u662f\u771f\u6b63\u7684\u5bc6\u6587\u3002\u56e0\u6b64\u4e00\u6b21\u6027\u5bc6\u7801\u672c\u662f\u65e0\u6cd5\u7834\u8bd1\u7684\u3002</p> <p>\u4f46\u4e00\u6b21\u6027\u5bc6\u7801\u672c\u662f\u4e0d\u5b9e\u7528\u7684\u3002\u56e0\u4e3a\u5bc6\u94a5\u914d\u9001\u548c\u4fdd\u5b58\u65e0\u6cd5\u4fdd\u8bc1\u5b89\u5168\uff08\u5426\u5219\u53ef\u76f4\u63a5\u4fdd\u62a4\u660e\u6587\u5b89\u5168\uff09\uff0c\u5bc6\u7801\u96be\u4ee5\u91cd\u7528\u3001\u957f\u5ea6\u8fc7\u957f\u3001\u96be\u4ee5\u751f\u6210\u7b49\u90fd\u662f\u95ee\u9898\u3002</p>"},{"location":"learn/cryptography/General/#des","title":"DES","text":""},{"location":"learn/cryptography/General/#des_1","title":"\u666e\u901aDES","text":"<p>DES\u7684\u57fa\u672c\u7ed3\u6784\uff0c\u79f0\u4e3aFeistel\u7f51\u7edc\u3002</p> <p>DES\u7684\u4e00\u8f6e\u52a0\u5bc6\u65b9\u6cd5 1. \u53f3\u4fa7\u4e0d\u53d8 2. \u8f6e\u51fd\u6570\u901a\u8fc7\u53f3\u4fa7\u548c\u5b50\u5bc6\u94a5\uff0c\u8ba1\u7b97\u51fa\u770b\u4e0a\u53bb\u968f\u673a\u7684\u6bd4\u7279\u5e8f\u5217 3. \u5c06\u6bd4\u7279\u5e8f\u5217\u548c\u5de6\u4fa7\u6570\u636eXOR\uff0c\u4f5c\u4e3a\u52a0\u5bc6\u540e\u7684\u5de6\u4fa7</p> <p>DES\u6bcf\u4e24\u8f6e\u4e4b\u95f4\u4ea4\u6362\u5de6\u4fa7\u548c\u53f3\u4fa7\uff0c\u591a\u8f6e\u52a0\u5bc6\u3002</p> <p>\u89e3\u5bc6\u65f6\uff0c\u53ea\u8981\u5404\u8f6e\u53cd\u8fc7\u6765\u6267\u884c\u4e00\u904d\u5373\u53ef\u3002\u53ef\u4ee5\u7528\u5b8c\u5168\u76f8\u540c\u7684\u7ed3\u6784\u52a0\u5bc6\u548c\u89e3\u5bc6\u3002</p> <p>\u9009\u62e9\u660e\u6587\u653b\u51fb\uff1a\u5982\u679c\u7834\u8bd1\u8005\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u660e\u6587\u5e76\u5f97\u5230\u52a0\u5bc6\u7ed3\u679c\uff0c\u90a3\u4e48\u53ef\u901a\u8fc7\u5dee\u5206\u5206\u6790\u548c\u7ebf\u6027\u5206\u6790\u7684\u65b9\u6cd5\u6765\u5c1d\u8bd5\u7834\u8bd1\u3002</p>"},{"location":"learn/cryptography/General/#des_2","title":"\u4e09\u91cdDES","text":"<p>\u5206\u522b\u7528\u4e09\u4e2a\u4e0d\u540c\u7684\u5bc6\u94a5\u8fdb\u884c\u52a0\u5bc6-\u89e3\u5bc6-\u52a0\u5bc6\uff0c\u5f97\u5230\u6700\u540e\u7684\u5bc6\u6587\u3002</p> <p>\u8fd9\u4e2a\u987a\u5e8f\u662f\u4e3a\u4e86\u4fdd\u8bc1\u5411\u4e0b\u517c\u5bb9\u6027\uff0c\u5f53\u4e09\u4e2a\u5bc6\u94a5\u76f8\u540c\u5c31\u6210\u4e86\u666e\u901aDES\u3002</p>"}]}