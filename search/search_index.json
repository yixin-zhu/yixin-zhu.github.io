{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":""},{"location":"#learn","title":"Learn","text":""},{"location":"#play","title":"Play","text":""},{"location":"about/","title":"I am Yixin","text":""},{"location":"about/#friend-link","title":"Friend Link","text":""},{"location":"about/#yilins-blog","title":"Yilin's blog","text":"<p>https://elin16.github.io/</p>"},{"location":"learn/algorithm/unionFind/","title":"Union Find","text":""},{"location":"learn/algorithm/unionFind/#dynamic-connectivity","title":"Dynamic connectivity","text":"<pre><code>public class UF{\n    UF(int N) //initialize union-find data structure with N objects (0 to N \u2013 1)\n\n    // Find query.  Check if two objects are in the same component.\n    boolean connected(int p, int q) // are p and q in the same component?\n\n    // Union command.  Replace components containing two objects with their union.\n    void union(int p, int q) add connection between p and q\n}\n\n</code></pre>"},{"location":"learn/algorithm/unionFind/#quick-find","title":"Quick Find","text":"<p>Data structure. - Integer array id[] of length N. - Interpretation:  p and q are connected iff they have the same id.</p> <pre><code>// O(1)\npublic boolean connected(int p, int q) \n   {  return id[p] == id[q];  }\n\n// O(N)\npublic void union(int p, int q){\n   {\n      int pid = id[p];\n      int qid = id[q];\n      for (int i = 0; i &lt; id.length; i++) \n         if (id[i] == pid) id[i] = qid;\n   }\n}\n</code></pre>"},{"location":"learn/algorithm/unionFind/#quick-union","title":"Quick Union","text":"<p>Data structure. - Integer array id[] of length N. - Interpretation:  id[i] is parent of i. \u027eRoot of i is id[id[id[...id[i]...]]].</p> <pre><code>private int root(int i)\n   {\n      while (i != id[i]) i = id[i];  // go to root\n      return i;\n   }\n\n// O(N)\npublic boolean connected(int p, int q) \n   {  return root(p) == root(q);  }\n\n// O(N)\npublic void union(int p, int q){\n   {\n      int i = root(p);\n      int j = root(q);\n      id[i] = j;\n   }\n}\n</code></pre>"},{"location":"learn/algorithm/unionFind/#union-find_1","title":"Union Find","text":""},{"location":"learn/algorithm/unionFind/#improvement1-weighting","title":"Improvement1: Weighting","text":"<p>Weighted quick-union. - Modify quick-union to avoid tall trees. - Keep track of size of each tree (number of objects).  - Balance by linking root of smaller tree to root of larger tree.</p> <p>Data structure.  - Same as quick-union, but maintain extra array sz[i] to count number of objects in the tree rooted at i.</p> <pre><code>private int root(int i)\n   {\n      while (i != id[i]) i = id[i];  // go to root\n      return i;\n   }\n\n// O(lgN) This is because Depth of any node x is at most lg N.\npublic boolean connected(int p, int q) \n   {  return root(p) == root(q);  }\n\n// O(lgN)\npublic void union(int p, int q){\n   {\n      int i = root(p);\n      int j = root(q);\n      if (i == j) return;\n      if  (sz[i] &lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } \n      else                { id[j] = i; sz[i] += sz[j]; }\n   }\n}\n</code></pre>"},{"location":"learn/algorithm/unionFind/#improvement2-path-compression","title":"Improvement2: path compression","text":"<p>Quick union with path compression. - Just after computing the root of p, set the id of each examined node to point to that root.</p> <p>Data structure.  - Same as quick-union, but maintain extra array sz[i] to count number of objects in the tree rooted at i.</p> <pre><code>private int root(int i)\n   {\n      while (i != id[i]){\n        id[i] = id[id[i]]; // only one extra code! In practice, just set the node to its grandparent, no need to root.\n        i = id[i];\n      }   \n      return i;\n   }\n\n// O(lgN) This is because Depth of any node x is at most lg N.\npublic boolean connected(int p, int q) \n   {  return root(p) == root(q);  }\n\n// O(lgN)\npublic void union(int p, int q){\n   {\n      int i = root(p);\n      int j = root(q);\n      if (i == j) return;\n      if  (sz[i] &lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } \n      else                { id[j] = i; sz[i] += sz[j]; }\n   }\n}\n</code></pre> <p>Proposition.  </p> <p>[Hopcroft-Ulman, Tarjan] Starting from an empty data structure, any sequence of M union-find operationss on N objects makes \u2264  c ( N + M lg N ) array accesses.  (log is iterate log)</p> <ul> <li>Analysis can be improved to N + M \u03b1(M, N).</li> <li>Simple algorithm with fascinating mathematics.</li> <li>In practice, WQUPC is near linear!</li> </ul>"}]}